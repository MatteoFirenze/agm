/*import_begin*/
import { Component, Input } from '@angular/core';
import * as GC from '@grapecity/spread-sheets';
import * as i0 from "@angular/core";
/*import_end*/
/*code_begin*/
export class ColumnComponent {
    constructor() {
        this.changes = {};
    }
    onAttached(sheet, index) {
        this.sheet = sheet;
        this.index = index;
        this.onColumnChanged();
    }
    onColumnChanged() {
        if (this.sheet) {
            const sheet = this.sheet;
            sheet.suspendPaint();
            sheet.suspendEvent();
            const changes = this.changes;
            for (const changeName in changes) {
                let newValue = changes[changeName].currentValue;
                if (newValue === null || newValue === void 0) {
                    continue;
                }
                switch (changeName) {
                    case 'width':
                        newValue = parseInt(newValue, 10);
                        sheet.setColumnWidth(this.index, newValue);
                        break;
                    case 'visible':
                        sheet.setColumnVisible(this.index, newValue);
                        break;
                    case 'resizable':
                        sheet.setColumnResizable(this.index, newValue);
                        break;
                    case 'autoFit':
                        if (newValue) {
                            sheet.autoFitColumn(this.index);
                        }
                        break;
                    case 'style':
                        sheet.setStyle(-1, this.index, newValue);
                        break;
                    case 'headerStyle':
                        sheet.setStyle(-1, this.index, newValue, GC.Spread.Sheets.SheetArea.colHeader);
                        break;
                    case 'cellType':
                        sheet.setCellType(-1, this.index, newValue);
                        break;
                    case 'formatter':
                        sheet.setFormatter(-1, this.index, newValue, GC.Spread.Sheets.SheetArea.viewport);
                        break;
                }
            }
            sheet.resumeEvent();
            sheet.resumePaint();
        }
    }
    ngOnChanges(changes) {
        this.changes = {};
        const changesCache = this.changes;
        for (const changeName in changes) {
            changesCache[changeName] = changes[changeName];
        }
        this.onColumnChanged();
    }
}
ColumnComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: ColumnComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ColumnComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.4.0", type: ColumnComponent, selector: "gc-column", inputs: { width: "width", dataField: "dataField", headerText: "headerText", visible: "visible", resizable: "resizable", autoFit: "autoFit", style: "style", cellType: "cellType", headerStyle: "headerStyle", formatter: "formatter" }, usesOnChanges: true, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: ColumnComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'gc-column',
                    template: `
        <ng-content></ng-content>
    `,
                }]
        }], propDecorators: { width: [{
                type: Input
            }], dataField: [{
                type: Input
            }], headerText: [{
                type: Input
            }], visible: [{
                type: Input
            }], resizable: [{
                type: Input
            }], autoFit: [{
                type: Input
            }], style: [{
                type: Input
            }], cellType: [{
                type: Input
            }], headerStyle: [{
                type: Input
            }], formatter: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb2x1bW4uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQjtBQUNoQixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBNEIsTUFBTSxlQUFlLENBQUM7QUFDM0UsT0FBTyxLQUFLLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7QUFDL0MsY0FBYztBQUVkLGNBQWM7QUFPZCxNQUFNLE9BQU8sZUFBZTtJQU41QjtRQU9VLFlBQU8sR0FBUSxFQUFFLENBQUM7S0E0RTNCO0lBNURRLFVBQVUsQ0FBQyxLQUFpQyxFQUFFLEtBQWE7UUFDaEUsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFTyxlQUFlO1FBQ3JCLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7WUFDekIsS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3JCLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUNyQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQzdCLEtBQUssTUFBTSxVQUFVLElBQUksT0FBTyxFQUFFO2dCQUNoQyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsWUFBWSxDQUFDO2dCQUNoRCxJQUFJLFFBQVEsS0FBSyxJQUFJLElBQUksUUFBUSxLQUFLLEtBQUssQ0FBQyxFQUFFO29CQUM1QyxTQUFTO2lCQUNWO2dCQUNELFFBQVEsVUFBVSxFQUFFO29CQUNsQixLQUFLLE9BQU87d0JBQ1YsUUFBUSxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7d0JBQ2xDLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQWUsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDckQsTUFBTTtvQkFDUixLQUFLLFNBQVM7d0JBQ1osS0FBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFlLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBQ3ZELE1BQU07b0JBQ1IsS0FBSyxXQUFXO3dCQUNkLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsS0FBZSxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUN6RCxNQUFNO29CQUNSLEtBQUssU0FBUzt3QkFDWixJQUFJLFFBQVEsRUFBRTs0QkFDWixLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFlLENBQUMsQ0FBQzt5QkFDM0M7d0JBQ0QsTUFBTTtvQkFDUixLQUFLLE9BQU87d0JBQ1YsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBZSxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUNuRCxNQUFNO29CQUNSLEtBQUssYUFBYTt3QkFDaEIsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBZSxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7d0JBQ3pGLE1BQU07b0JBQ1IsS0FBSyxVQUFVO3dCQUNiLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQWUsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDdEQsTUFBTTtvQkFDUixLQUFLLFdBQVc7d0JBQ2QsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBZSxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBQzVGLE1BQU07aUJBQ1Q7YUFDRjtZQUNELEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNwQixLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDckI7SUFDSCxDQUFDO0lBRU0sV0FBVyxDQUFDLE9BQXNCO1FBQ3ZDLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2xCLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDbEMsS0FBSyxNQUFNLFVBQVUsSUFBSSxPQUFPLEVBQUU7WUFDaEMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUNoRDtRQUNELElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN6QixDQUFDOzs0R0E1RVUsZUFBZTtnR0FBZixlQUFlLDhTQUpoQjs7S0FFUDsyRkFFUSxlQUFlO2tCQU4zQixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxXQUFXO29CQUNyQixRQUFRLEVBQUU7O0tBRVA7aUJBQ0o7OEJBT2lCLEtBQUs7c0JBQXBCLEtBQUs7Z0JBQ1UsU0FBUztzQkFBeEIsS0FBSztnQkFDVSxVQUFVO3NCQUF6QixLQUFLO2dCQUNVLE9BQU87c0JBQXRCLEtBQUs7Z0JBQ1UsU0FBUztzQkFBeEIsS0FBSztnQkFDVSxPQUFPO3NCQUF0QixLQUFLO2dCQUNVLEtBQUs7c0JBQXBCLEtBQUs7Z0JBQ1UsUUFBUTtzQkFBdkIsS0FBSztnQkFDVSxXQUFXO3NCQUExQixLQUFLO2dCQUNVLFNBQVM7c0JBQXhCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyIvKmltcG9ydF9iZWdpbiovXHJcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBHQyBmcm9tICdAZ3JhcGVjaXR5L3NwcmVhZC1zaGVldHMnO1xyXG4vKmltcG9ydF9lbmQqL1xyXG5cclxuLypjb2RlX2JlZ2luKi9cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdnYy1jb2x1bW4nLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxyXG4gICAgYCxcclxufSlcclxuZXhwb3J0IGNsYXNzIENvbHVtbkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XHJcbiAgcHJpdmF0ZSBjaGFuZ2VzOiBhbnkgPSB7fTtcclxuICBwcml2YXRlIHNoZWV0PzogR0MuU3ByZWFkLlNoZWV0cy5Xb3Jrc2hlZXQ7XHJcbiAgcHJpdmF0ZSBpbmRleD86IG51bWJlcjtcclxuXHJcbiAgLy8gaW5kaWNhdGUgYWxsIGlucHV0c1xyXG4gIEBJbnB1dCgpIHB1YmxpYyB3aWR0aD86IG51bWJlciB8IHN0cmluZztcclxuICBASW5wdXQoKSBwdWJsaWMgZGF0YUZpZWxkPzogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXJUZXh0Pzogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIHB1YmxpYyB2aXNpYmxlPzogYm9vbGVhbjtcclxuICBASW5wdXQoKSBwdWJsaWMgcmVzaXphYmxlPzogYm9vbGVhbjtcclxuICBASW5wdXQoKSBwdWJsaWMgYXV0b0ZpdD86IGJvb2xlYW47XHJcbiAgQElucHV0KCkgcHVibGljIHN0eWxlPzogR0MuU3ByZWFkLlNoZWV0cy5TdHlsZTtcclxuICBASW5wdXQoKSBwdWJsaWMgY2VsbFR5cGU/OiBHQy5TcHJlYWQuU2hlZXRzLkNlbGxUeXBlcy5CYXNlO1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXJTdHlsZT86IEdDLlNwcmVhZC5TaGVldHMuU3R5bGU7XHJcbiAgQElucHV0KCkgcHVibGljIGZvcm1hdHRlcjogYW55O1xyXG5cclxuICBwdWJsaWMgb25BdHRhY2hlZChzaGVldDogR0MuU3ByZWFkLlNoZWV0cy5Xb3Jrc2hlZXQsIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcclxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgIHRoaXMub25Db2x1bW5DaGFuZ2VkKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uQ29sdW1uQ2hhbmdlZCgpIHtcclxuICAgIGlmICh0aGlzLnNoZWV0KSB7XHJcbiAgICAgIGNvbnN0IHNoZWV0ID0gdGhpcy5zaGVldDtcclxuICAgICAgc2hlZXQuc3VzcGVuZFBhaW50KCk7XHJcbiAgICAgIHNoZWV0LnN1c3BlbmRFdmVudCgpO1xyXG4gICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzO1xyXG4gICAgICBmb3IgKGNvbnN0IGNoYW5nZU5hbWUgaW4gY2hhbmdlcykge1xyXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGNoYW5nZXNbY2hhbmdlTmFtZV0uY3VycmVudFZhbHVlO1xyXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChjaGFuZ2VOYW1lKSB7XHJcbiAgICAgICAgICBjYXNlICd3aWR0aCc6XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gcGFyc2VJbnQobmV3VmFsdWUsIDEwKTtcclxuICAgICAgICAgICAgc2hlZXQuc2V0Q29sdW1uV2lkdGgodGhpcy5pbmRleCBhcyBudW1iZXIsIG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICd2aXNpYmxlJzpcclxuICAgICAgICAgICAgc2hlZXQuc2V0Q29sdW1uVmlzaWJsZSh0aGlzLmluZGV4IGFzIG51bWJlciwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3Jlc2l6YWJsZSc6XHJcbiAgICAgICAgICAgIHNoZWV0LnNldENvbHVtblJlc2l6YWJsZSh0aGlzLmluZGV4IGFzIG51bWJlciwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2F1dG9GaXQnOlxyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICBzaGVldC5hdXRvRml0Q29sdW1uKHRoaXMuaW5kZXggYXMgbnVtYmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcclxuICAgICAgICAgICAgc2hlZXQuc2V0U3R5bGUoLTEsIHRoaXMuaW5kZXggYXMgbnVtYmVyLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnaGVhZGVyU3R5bGUnOlxyXG4gICAgICAgICAgICBzaGVldC5zZXRTdHlsZSgtMSwgdGhpcy5pbmRleCBhcyBudW1iZXIsIG5ld1ZhbHVlLCBHQy5TcHJlYWQuU2hlZXRzLlNoZWV0QXJlYS5jb2xIZWFkZXIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2NlbGxUeXBlJzpcclxuICAgICAgICAgICAgc2hlZXQuc2V0Q2VsbFR5cGUoLTEsIHRoaXMuaW5kZXggYXMgbnVtYmVyLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnZm9ybWF0dGVyJzpcclxuICAgICAgICAgICAgc2hlZXQuc2V0Rm9ybWF0dGVyKC0xLCB0aGlzLmluZGV4IGFzIG51bWJlciwgbmV3VmFsdWUsIEdDLlNwcmVhZC5TaGVldHMuU2hlZXRBcmVhLnZpZXdwb3J0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNoZWV0LnJlc3VtZUV2ZW50KCk7XHJcbiAgICAgIHNoZWV0LnJlc3VtZVBhaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgdGhpcy5jaGFuZ2VzID0ge307XHJcbiAgICBjb25zdCBjaGFuZ2VzQ2FjaGUgPSB0aGlzLmNoYW5nZXM7XHJcbiAgICBmb3IgKGNvbnN0IGNoYW5nZU5hbWUgaW4gY2hhbmdlcykge1xyXG4gICAgICBjaGFuZ2VzQ2FjaGVbY2hhbmdlTmFtZV0gPSBjaGFuZ2VzW2NoYW5nZU5hbWVdO1xyXG4gICAgfVxyXG4gICAgdGhpcy5vbkNvbHVtbkNoYW5nZWQoKTtcclxuICB9XHJcbn1cclxuLypjb2RlX2VuZCovXHJcbiJdfQ==